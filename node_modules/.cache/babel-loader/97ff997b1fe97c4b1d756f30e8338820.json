{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport * as tf from '@tensorflow/tfjs-core'; // TODO: remove this once PR is merged and published\n\nvar DTYPE_VALUE_SIZE_MAP = {\n  'float32': 4,\n  'int32': 4,\n  'uint16': 2,\n  'uint8': 1,\n  'bool': 1\n};\nexport function weightsLoaderFactory(fetchWeightsFunction) {\n  var _this = this;\n\n  return function (manifest, filePathPrefix, weightNames) {\n    if (filePathPrefix === void 0) {\n      filePathPrefix = '';\n    }\n\n    return tslib_1.__awaiter(_this, void 0, void 0, function () {\n      var groupIndicesToFetchMap, groupWeightsToFetch, weightsFound, allManifestWeightNames, weightsNotFound, groupIndicesToFetch, fetchUrls, buffers, weightsTensorMap, bufferIndexOffset;\n      return tslib_1.__generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            groupIndicesToFetchMap = manifest.map(function () {\n              return false;\n            });\n            groupWeightsToFetch = {};\n            weightsFound = weightNames != null ? weightNames.map(function () {\n              return false;\n            }) : [];\n            allManifestWeightNames = [];\n            manifest.forEach(function (manifestGroupConfig, groupIndex) {\n              var groupOffset = 0;\n              manifestGroupConfig.weights.forEach(function (weightsEntry) {\n                var rawDtype = weightsEntry.quantization ? weightsEntry.quantization.dtype : weightsEntry.dtype;\n                var weightsBytes = DTYPE_VALUE_SIZE_MAP[rawDtype] * tf.util.sizeFromShape(weightsEntry.shape);\n\n                var enqueueWeightsForFetchingFn = function enqueueWeightsForFetchingFn() {\n                  groupIndicesToFetchMap[groupIndex] = true;\n\n                  if (groupWeightsToFetch[groupIndex] == null) {\n                    groupWeightsToFetch[groupIndex] = [];\n                  }\n\n                  groupWeightsToFetch[groupIndex].push({\n                    manifestEntry: weightsEntry,\n                    groupOffset: groupOffset,\n                    sizeBytes: weightsBytes\n                  });\n                };\n\n                if (weightNames != null) {\n                  weightNames.forEach(function (weightName, weightIndex) {\n                    if (weightName === weightsEntry.name) {\n                      enqueueWeightsForFetchingFn();\n                      weightsFound[weightIndex] = true;\n                    }\n                  });\n                } else {\n                  enqueueWeightsForFetchingFn();\n                }\n\n                allManifestWeightNames.push(weightsEntry.name);\n                groupOffset += weightsBytes;\n              });\n            });\n\n            if (!weightsFound.every(function (found) {\n              return found;\n            }) && weightNames) {\n              weightsNotFound = weightNames.filter(function (_, i) {\n                return !weightsFound[i];\n              });\n              throw new Error(\"Could not find weights in manifest with names: \" + (weightsNotFound.join(', ') + \". \\n\") + \"Manifest JSON has weights with names: \" + (allManifestWeightNames.join(', ') + \".\"));\n            }\n\n            groupIndicesToFetch = groupIndicesToFetchMap.reduce(function (accumulator, shouldFetch, i) {\n              if (shouldFetch) {\n                accumulator.push(i);\n              }\n\n              return accumulator;\n            }, []);\n            fetchUrls = [];\n            groupIndicesToFetch.forEach(function (i) {\n              manifest[i].paths.forEach(function (filepath) {\n                var fetchUrl = filePathPrefix + (!filePathPrefix.endsWith('/') ? '/' : '') + filepath;\n                fetchUrls.push(fetchUrl);\n              });\n            });\n            return [4\n            /*yield*/\n            , fetchWeightsFunction(fetchUrls)];\n\n          case 1:\n            buffers = _a.sent();\n            weightsTensorMap = {};\n            bufferIndexOffset = 0;\n            groupIndicesToFetch.forEach(function (i) {\n              var numBuffers = manifest[i].paths.length;\n              var groupBytes = 0;\n\n              for (var i_1 = 0; i_1 < numBuffers; i_1++) {\n                groupBytes += buffers[bufferIndexOffset + i_1].byteLength;\n              } // Create a buffer for the whole group.\n\n\n              var groupBuffer = new ArrayBuffer(groupBytes);\n              var groupByteBuffer = new Uint8Array(groupBuffer);\n              var groupBufferOffset = 0;\n\n              for (var i_2 = 0; i_2 < numBuffers; i_2++) {\n                var buffer = new Uint8Array(buffers[bufferIndexOffset + i_2]);\n                groupByteBuffer.set(buffer, groupBufferOffset);\n                groupBufferOffset += buffer.byteLength;\n              }\n\n              var weightsEntries = groupWeightsToFetch[i];\n              weightsEntries.forEach(function (weightsEntry) {\n                var byteBuffer = groupBuffer.slice(weightsEntry.groupOffset, weightsEntry.groupOffset + weightsEntry.sizeBytes);\n                var nameToTensorMap = tf.io.decodeWeights(byteBuffer, [weightsEntry.manifestEntry]);\n\n                for (var name_1 in nameToTensorMap) {\n                  weightsTensorMap[name_1] = nameToTensorMap[name_1];\n                }\n              });\n              bufferIndexOffset += numBuffers;\n            });\n            return [2\n            /*return*/\n            , weightsTensorMap];\n        }\n      });\n    });\n  };\n}","map":null,"metadata":{},"sourceType":"module"}