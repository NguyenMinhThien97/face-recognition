{"ast":null,"code":"import * as tf from '@tensorflow/tfjs-core';\nimport { BoundingBox, Dimensions, iou, Rect } from 'tfjs-image-recognition-base';\nimport { CELL_SIZE } from './const';\n\nvar TinyYolov2LossFunction =\n/** @class */\nfunction () {\n  function TinyYolov2LossFunction(outputTensor, groundTruth, predictedBoxes, reshapedImgDims, config) {\n    this._config = config;\n    this._reshapedImgDims = new Dimensions(reshapedImgDims.width, reshapedImgDims.height);\n    this._outputTensor = outputTensor;\n    this._predictedBoxes = predictedBoxes;\n    this.validateGroundTruthBoxes(groundTruth);\n    this._groundTruth = this.assignGroundTruthToAnchors(groundTruth);\n    var groundTruthMask = this.createGroundTruthMask();\n\n    var _a = this.createCoordAndScoreMasks(),\n        coordBoxOffsetMask = _a.coordBoxOffsetMask,\n        coordBoxSizeMask = _a.coordBoxSizeMask,\n        scoreMask = _a.scoreMask;\n\n    this.noObjectLossMask = tf.tidy(function () {\n      return tf.mul(scoreMask, tf.sub(tf.scalar(1), groundTruthMask));\n    });\n    this.objectLossMask = tf.tidy(function () {\n      return tf.mul(scoreMask, groundTruthMask);\n    });\n    this.coordBoxOffsetMask = tf.tidy(function () {\n      return tf.mul(coordBoxOffsetMask, groundTruthMask);\n    });\n    this.coordBoxSizeMask = tf.tidy(function () {\n      return tf.mul(coordBoxSizeMask, groundTruthMask);\n    });\n    var classScoresMask = tf.tidy(function () {\n      return tf.sub(tf.scalar(1), coordBoxOffsetMask.add(coordBoxSizeMask).add(scoreMask));\n    });\n    this.groundTruthClassScoresMask = tf.tidy(function () {\n      return tf.mul(classScoresMask, groundTruthMask);\n    });\n  }\n\n  Object.defineProperty(TinyYolov2LossFunction.prototype, \"config\", {\n    get: function get() {\n      return this._config;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TinyYolov2LossFunction.prototype, \"reshapedImgDims\", {\n    get: function get() {\n      return this._reshapedImgDims;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TinyYolov2LossFunction.prototype, \"outputTensor\", {\n    get: function get() {\n      return this._outputTensor;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TinyYolov2LossFunction.prototype, \"groundTruth\", {\n    get: function get() {\n      return this._groundTruth;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TinyYolov2LossFunction.prototype, \"predictedBoxes\", {\n    get: function get() {\n      return this._predictedBoxes;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TinyYolov2LossFunction.prototype, \"inputSize\", {\n    get: function get() {\n      return Math.max(this.reshapedImgDims.width, this.reshapedImgDims.height);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TinyYolov2LossFunction.prototype, \"withClassScores\", {\n    get: function get() {\n      return this._config.withClassScores || this._config.classes.length > 1;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TinyYolov2LossFunction.prototype, \"boxEncodingSize\", {\n    get: function get() {\n      return 5 + (this.withClassScores ? this._config.classes.length : 0);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TinyYolov2LossFunction.prototype, \"anchors\", {\n    get: function get() {\n      return this._config.anchors;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TinyYolov2LossFunction.prototype, \"numBoxes\", {\n    get: function get() {\n      return this.anchors.length;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TinyYolov2LossFunction.prototype, \"numCells\", {\n    get: function get() {\n      return this.inputSize / CELL_SIZE;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TinyYolov2LossFunction.prototype, \"gridCellEncodingSize\", {\n    get: function get() {\n      return this.boxEncodingSize * this.numBoxes;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  TinyYolov2LossFunction.prototype.toOutputTensorShape = function (tensor) {\n    var _this = this;\n\n    return tf.tidy(function () {\n      return tensor.reshape([1, _this.numCells, _this.numCells, _this.gridCellEncodingSize]);\n    });\n  };\n\n  TinyYolov2LossFunction.prototype.computeLoss = function () {\n    var _this = this;\n\n    return tf.tidy(function () {\n      var noObjectLoss = _this.computeNoObjectLoss();\n\n      var objectLoss = _this.computeObjectLoss();\n\n      var coordLoss = _this.computeCoordLoss();\n\n      var classLoss = _this.withClassScores ? _this.computeClassLoss() : tf.scalar(0);\n      var totalLoss = tf.tidy(function () {\n        return noObjectLoss.add(objectLoss).add(coordLoss).add(classLoss);\n      });\n      return {\n        noObjectLoss: noObjectLoss,\n        objectLoss: objectLoss,\n        coordLoss: coordLoss,\n        classLoss: classLoss,\n        totalLoss: totalLoss\n      };\n    });\n  };\n\n  TinyYolov2LossFunction.prototype.computeNoObjectLoss = function () {\n    var _this = this;\n\n    return tf.tidy(function () {\n      return _this.computeLossTerm(_this.config.noObjectScale, _this.toOutputTensorShape(_this.noObjectLossMask), tf.sigmoid(_this.outputTensor));\n    });\n  };\n\n  TinyYolov2LossFunction.prototype.computeObjectLoss = function () {\n    var _this = this;\n\n    return tf.tidy(function () {\n      return _this.computeLossTerm(_this.config.objectScale, _this.toOutputTensorShape(_this.objectLossMask), tf.sub(_this.toOutputTensorShape(_this.computeIous()), tf.sigmoid(_this.outputTensor)));\n    });\n  };\n\n  TinyYolov2LossFunction.prototype.computeClassLoss = function () {\n    var _this = this;\n\n    return tf.tidy(function () {\n      var classLossTensor = tf.tidy(function () {\n        var predClassScores = tf.mul(tf.softmax(_this.outputTensor.reshape([_this.numCells, _this.numCells, _this.numBoxes, _this.boxEncodingSize]), 3), _this.groundTruthClassScoresMask);\n\n        var gtClassScores = _this.createOneHotClassScoreMask();\n\n        return tf.sub(gtClassScores, predClassScores);\n      });\n      return _this.computeLossTerm(_this.config.classScale, tf.scalar(1), classLossTensor);\n    });\n  };\n\n  TinyYolov2LossFunction.prototype.computeCoordLoss = function () {\n    var _this = this;\n\n    return tf.tidy(function () {\n      return _this.computeLossTerm(_this.config.coordScale, tf.scalar(1), tf.add(_this.computeCoordBoxOffsetError(), _this.computeCoordBoxSizeError()));\n    });\n  };\n\n  TinyYolov2LossFunction.prototype.computeCoordBoxOffsetError = function () {\n    var _this = this;\n\n    return tf.tidy(function () {\n      var mask = _this.toOutputTensorShape(_this.coordBoxOffsetMask);\n\n      var gtBoxOffsets = tf.mul(mask, _this.toOutputTensorShape(_this.computeCoordBoxOffsets()));\n      var predBoxOffsets = tf.mul(mask, tf.sigmoid(_this.outputTensor));\n      return tf.sub(gtBoxOffsets, predBoxOffsets);\n    });\n  };\n\n  TinyYolov2LossFunction.prototype.computeCoordBoxSizeError = function () {\n    var _this = this;\n\n    return tf.tidy(function () {\n      var mask = _this.toOutputTensorShape(_this.coordBoxSizeMask);\n\n      var gtBoxSizes = tf.mul(mask, _this.toOutputTensorShape(_this.computeCoordBoxSizes()));\n      var predBoxSizes = tf.mul(mask, _this.outputTensor);\n      return tf.sub(gtBoxSizes, predBoxSizes);\n    });\n  };\n\n  TinyYolov2LossFunction.prototype.computeLossTerm = function (scale, mask, lossTensor) {\n    var _this = this;\n\n    return tf.tidy(function () {\n      return tf.mul(tf.scalar(scale), _this.squaredSumOverMask(mask, lossTensor));\n    });\n  };\n\n  TinyYolov2LossFunction.prototype.squaredSumOverMask = function (mask, lossTensor) {\n    return tf.tidy(function () {\n      return tf.sum(tf.square(tf.mul(mask, lossTensor)));\n    });\n  };\n\n  TinyYolov2LossFunction.prototype.validateGroundTruthBoxes = function (groundTruth) {\n    var _this = this;\n\n    groundTruth.forEach(function (_a) {\n      var x = _a.x,\n          y = _a.y,\n          width = _a.width,\n          height = _a.height,\n          label = _a.label;\n\n      if (typeof label !== 'number' || label < 0 || label > _this.config.classes.length - 1) {\n        throw new Error(\"invalid ground truth data, expected label to be a number in [0, \" + (_this.config.classes.length - 1) + \"]\");\n      }\n\n      if (x < 0 || x > 1 || y < 0 || y > 1 || width < 0 || x + width > 1 || height < 0 || y + height > 1) {\n        throw new Error(\"invalid ground truth data, box is out of image boundaries \" + JSON.stringify({\n          x: x,\n          y: y,\n          width: width,\n          height: height\n        }));\n      }\n    });\n  };\n\n  TinyYolov2LossFunction.prototype.assignGroundTruthToAnchors = function (groundTruth) {\n    var _this = this;\n\n    var groundTruthBoxes = groundTruth.map(function (_a) {\n      var x = _a.x,\n          y = _a.y,\n          width = _a.width,\n          height = _a.height,\n          label = _a.label;\n      return {\n        box: new Rect(x, y, width, height),\n        label: label\n      };\n    });\n    return groundTruthBoxes.map(function (_a) {\n      var box = _a.box,\n          label = _a.label;\n\n      var _b = box.rescale(_this.reshapedImgDims),\n          left = _b.left,\n          top = _b.top,\n          bottom = _b.bottom,\n          right = _b.right,\n          x = _b.x,\n          y = _b.y,\n          width = _b.width,\n          height = _b.height;\n\n      var ctX = left + width / 2;\n      var ctY = top + height / 2;\n      var col = Math.floor(ctX / _this.inputSize * _this.numCells);\n      var row = Math.floor(ctY / _this.inputSize * _this.numCells);\n\n      var anchorsByIou = _this.anchors.map(function (anchor, idx) {\n        return {\n          idx: idx,\n          iou: iou(new BoundingBox(0, 0, anchor.x * CELL_SIZE, anchor.y * CELL_SIZE), new BoundingBox(0, 0, width, height))\n        };\n      }).sort(function (a1, a2) {\n        return a2.iou - a1.iou;\n      });\n\n      var anchor = anchorsByIou[0].idx;\n      return {\n        row: row,\n        col: col,\n        anchor: anchor,\n        box: box,\n        label: label\n      };\n    });\n  };\n\n  TinyYolov2LossFunction.prototype.createGroundTruthMask = function () {\n    var _this = this;\n\n    var mask = tf.zeros([this.numCells, this.numCells, this.numBoxes, this.boxEncodingSize]);\n    var buf = mask.buffer();\n    this.groundTruth.forEach(function (_a) {\n      var row = _a.row,\n          col = _a.col,\n          anchor = _a.anchor;\n\n      for (var i = 0; i < _this.boxEncodingSize; i++) {\n        buf.set(1, row, col, anchor, i);\n      }\n    });\n    return mask;\n  };\n\n  TinyYolov2LossFunction.prototype.createCoordAndScoreMasks = function () {\n    var _this = this;\n\n    return tf.tidy(function () {\n      var coordBoxOffsetMask = tf.zeros([_this.numCells, _this.numCells, _this.numBoxes, _this.boxEncodingSize]);\n      var coordBoxSizeMask = tf.zeros([_this.numCells, _this.numCells, _this.numBoxes, _this.boxEncodingSize]);\n      var scoreMask = tf.zeros([_this.numCells, _this.numCells, _this.numBoxes, _this.boxEncodingSize]);\n      var coordBoxOffsetBuf = coordBoxOffsetMask.buffer();\n      var coordBoxSizeBuf = coordBoxSizeMask.buffer();\n      var scoreBuf = scoreMask.buffer();\n\n      for (var row = 0; row < _this.numCells; row++) {\n        for (var col = 0; col < _this.numCells; col++) {\n          for (var anchor = 0; anchor < _this.numBoxes; anchor++) {\n            coordBoxOffsetBuf.set(1, row, col, anchor, 0);\n            coordBoxOffsetBuf.set(1, row, col, anchor, 1);\n            coordBoxSizeBuf.set(1, row, col, anchor, 2);\n            coordBoxSizeBuf.set(1, row, col, anchor, 3);\n            scoreBuf.set(1, row, col, anchor, 4);\n          }\n        }\n      }\n\n      return {\n        coordBoxOffsetMask: coordBoxOffsetMask,\n        coordBoxSizeMask: coordBoxSizeMask,\n        scoreMask: scoreMask\n      };\n    });\n  };\n\n  TinyYolov2LossFunction.prototype.createOneHotClassScoreMask = function () {\n    var mask = tf.zeros([this.numCells, this.numCells, this.numBoxes, this.boxEncodingSize]);\n    var buf = mask.buffer();\n    var classValuesOffset = 5;\n    this.groundTruth.forEach(function (_a) {\n      var row = _a.row,\n          col = _a.col,\n          anchor = _a.anchor,\n          label = _a.label;\n      buf.set(1, row, col, anchor, classValuesOffset + label);\n    });\n    return mask;\n  };\n\n  TinyYolov2LossFunction.prototype.computeIous = function () {\n    var _this = this;\n\n    var isSameAnchor = function isSameAnchor(p1) {\n      return function (p2) {\n        return p1.row === p2.row && p1.col === p2.col && p1.anchor === p2.anchor;\n      };\n    };\n\n    var ious = tf.zeros([this.numCells, this.numCells, this.gridCellEncodingSize]);\n    var buf = ious.buffer();\n    this.groundTruth.forEach(function (_a) {\n      var row = _a.row,\n          col = _a.col,\n          anchor = _a.anchor,\n          box = _a.box;\n\n      var predBox = _this.predictedBoxes.find(isSameAnchor({\n        row: row,\n        col: col,\n        anchor: anchor\n      }));\n\n      if (!predBox) {\n        throw new Error(\"no output box found for: row \" + row + \", col \" + col + \", anchor \" + anchor);\n      }\n\n      var boxIou = iou(box.rescale(_this.reshapedImgDims), predBox.box.rescale(_this.reshapedImgDims));\n      var anchorOffset = _this.boxEncodingSize * anchor;\n      var scoreValueOffset = 4;\n      buf.set(boxIou, row, col, anchorOffset + scoreValueOffset);\n    });\n    return ious;\n  };\n\n  TinyYolov2LossFunction.prototype.computeCoordBoxOffsets = function () {\n    var _this = this;\n\n    var offsets = tf.zeros([this.numCells, this.numCells, this.numBoxes, this.boxEncodingSize]);\n    var buf = offsets.buffer();\n    this.groundTruth.forEach(function (_a) {\n      var row = _a.row,\n          col = _a.col,\n          anchor = _a.anchor,\n          box = _a.box;\n\n      var _b = box.rescale(_this.reshapedImgDims),\n          left = _b.left,\n          top = _b.top,\n          right = _b.right,\n          bottom = _b.bottom;\n\n      var centerX = (left + right) / 2;\n      var centerY = (top + bottom) / 2;\n      var dCenterX = centerX - col * CELL_SIZE;\n      var dCenterY = centerY - row * CELL_SIZE; // inverseSigmoid(0) === -Infinity, inverseSigmoid(1) === Infinity\n      //const dx = inverseSigmoid(Math.min(0.999, Math.max(0.001, dCenterX / CELL_SIZE)))\n      //const dy = inverseSigmoid(Math.min(0.999, Math.max(0.001, dCenterY / CELL_SIZE)))\n\n      var dx = dCenterX / CELL_SIZE;\n      var dy = dCenterY / CELL_SIZE;\n      buf.set(dx, row, col, anchor, 0);\n      buf.set(dy, row, col, anchor, 1);\n    });\n    return offsets;\n  };\n\n  TinyYolov2LossFunction.prototype.computeCoordBoxSizes = function () {\n    var _this = this;\n\n    var sizes = tf.zeros([this.numCells, this.numCells, this.numBoxes, this.boxEncodingSize]);\n    var buf = sizes.buffer();\n    this.groundTruth.forEach(function (_a) {\n      var row = _a.row,\n          col = _a.col,\n          anchor = _a.anchor,\n          box = _a.box;\n\n      var _b = box.rescale(_this.reshapedImgDims),\n          width = _b.width,\n          height = _b.height;\n\n      var dw = Math.log(width / (_this.anchors[anchor].x * CELL_SIZE));\n      var dh = Math.log(height / (_this.anchors[anchor].y * CELL_SIZE));\n      buf.set(dw, row, col, anchor, 2);\n      buf.set(dh, row, col, anchor, 3);\n    });\n    return sizes;\n  };\n\n  return TinyYolov2LossFunction;\n}();\n\nexport { TinyYolov2LossFunction };","map":null,"metadata":{},"sourceType":"module"}